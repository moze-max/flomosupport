import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:mockito/annotations.dart';
import 'package:uuid/uuid.dart';

// Assuming your Template class is in template.dart
import 'package:flomosupport/models/guidemodel.dart'; // Adjust this import path

// We need to mock the Uuid class to control ID generation for testing
@GenerateNiceMocks([MockSpec<Uuid>()])
import 'guide_model_test.mocks.dart'; // This file will be generated by build_runner

void main() {
  // Declare the mock Uuid outside the group, so it can be re-mocked in setUp
  late MockUuid mockUuid;

  setUp(() {
    // Initialize a new mock Uuid for each test
    mockUuid = MockUuid();
    // Default mock behavior for uuid.v4()
    when(mockUuid.v4()).thenReturn('mock-uuid-1'); // Default ID for convenience
  });

  group('Template Class', () {
    test('Template constructor initializes all properties correctly', () {
      final template = Template(
        id: 'test-id-123',
        name: 'My Custom Template',
        items: [1, 2, 'hello'],
        imagePath: 'assets/images/template1.png',
      );

      expect(template.id, 'test-id-123');
      expect(template.name, 'My Custom Template');
      expect(template.items, equals([1, 2, 'hello']));
      expect(template.imagePath, 'assets/images/template1.png');
    });

    test('Template constructor handles default items correctly', () {
      final template = Template(
        id: 'test-id-456',
        name: 'Template with Default Items',
        imagePath: 'assets/images/default.png',
      );

      expect(template.id, 'test-id-456');
      expect(template.name, 'Template with Default Items');
      expect(template.items, isEmpty); // Default is const []
      expect(template.imagePath, 'assets/images/default.png');
    });

    test(
        'Template.create factory constructor generates a unique ID (with injection)',
        () {
      // Configure our mock Uuid instance to return a specific ID
      when(mockUuid.v4()).thenReturn('generated-mock-uuid');

      // Pass the mocked Uuid instance to Template.create
      final template = Template.create(
        name: 'Auto Generated Template with Mocked Uuid',
        items: ['item1'],
        uuidGenerator: mockUuid, // <-- 注入 mockUuid
      );

      // Verify uuid.v4() was called once on our mock
      verify(mockUuid.v4()).called(1);
      expect(template.id, 'generated-mock-uuid'); // Expect the mocked ID
      expect(template.name, 'Auto Generated Template with Mocked Uuid');
      expect(template.items, equals(['item1']));
      expect(template.imagePath, isNull);
    });

    test('Template.create handles null imagePath correctly', () {
      when(mockUuid.v4()).thenReturn('uuid-with-no-image');
      final template = Template.create(name: 'No Image Template');
      expect(template.imagePath, isNull);
    });

    // --- Test Cases for toJson() ---

    test('toJson converts Template to JSON map with all fields', () {
      final template = Template(
        id: 'json-id-1',
        name: 'JSON Template',
        items: [
          {'key': 'value'},
          true,
          123
        ],
        imagePath: 'path/to/image.jpg',
      );

      final jsonMap = template.toJson();

      expect(jsonMap, isA<Map<String, dynamic>>());
      expect(jsonMap['id'], 'json-id-1');
      expect(jsonMap['name'], 'JSON Template');
      expect(
          jsonMap['items'],
          equals([
            {'key': 'value'},
            true,
            123
          ]));
      expect(jsonMap['imagePath'], 'path/to/image.jpg');
    });

    test('toJson handles null imagePath correctly', () {
      final template = Template(
        id: 'json-id-2',
        name: 'Template Without Image',
      );

      final jsonMap = template.toJson();

      expect(jsonMap['id'], 'json-id-2');
      expect(jsonMap['name'], 'Template Without Image');
      expect(jsonMap['items'], isEmpty); // Default empty list
      expect(jsonMap['imagePath'], isNull);
    });

    test('toJson handles empty items list correctly', () {
      final template = Template(
        id: 'json-id-3',
        name: 'Template With Empty Items',
        items: [],
      );

      final jsonMap = template.toJson();

      expect(jsonMap['id'], 'json-id-3');
      expect(jsonMap['name'], 'Template With Empty Items');
      expect(jsonMap['items'], isEmpty);
      expect(jsonMap['imagePath'], isNull);
    });

    // --- Test Cases for fromJson() ---

    test('fromJson correctly parses a full JSON map', () {
      final jsonMap = {
        'id': 'from-json-id-1',
        'name': 'Parsed Template',
        'items': [
          {'itemKey': 'itemValue'},
          42
        ],
        'imagePath': 'images/parsed.png',
      };

      final template = Template.fromJson(jsonMap);

      expect(template.id, 'from-json-id-1');
      expect(template.name, 'Parsed Template');
      expect(
          template.items,
          equals([
            {'itemKey': 'itemValue'},
            42
          ]));
      expect(template.imagePath, 'images/parsed.png');
    });

    test('fromJson handles missing imagePath (null) correctly', () {
      final jsonMap = {
        'id': 'from-json-id-2',
        'name': 'Template Without Image',
        'items': [],
      };

      final template = Template.fromJson(jsonMap);

      expect(template.id, 'from-json-id-2');
      expect(template.name, 'Template Without Image');
      expect(template.items, isEmpty);
      expect(template.imagePath, isNull);
    });

    test('fromJson handles empty items list correctly', () {
      final jsonMap = {
        'id': 'from-json-id-3',
        'name': 'Template With Empty Items',
        'items': [],
        'imagePath': 'some/path.jpg',
      };

      final template = Template.fromJson(jsonMap);

      expect(template.id, 'from-json-id-3');
      expect(template.name, 'Template With Empty Items');
      expect(template.items, isEmpty);
      expect(template.imagePath, 'some/path.jpg');
    });

    test('fromJson handles missing items key (defaults to empty)', () {
      final jsonMap = {
        'id': 'from-json-id-4',
        'name': 'Template Missing Items Key',
        'imagePath': 'some/path.jpg',
      };
      expect(() => Template.fromJson(jsonMap), throwsA(isA<TypeError>()));
    });

    test('== returns true for Templates with the same id', () {
      final template1 = Template(id: 'same-id', name: 'Name1', items: ['a']);
      final template2 = Template(
          id: 'same-id',
          name: 'Name2',
          items: ['b']); // Name and items don't matter for equality

      expect(template1 == template2, isTrue);
    });

    test('== returns false for Templates with different ids', () {
      final template1 = Template(id: 'id-1', name: 'Template A');
      final template2 = Template(id: 'id-2', name: 'Template B');

      expect(template1 == template2, isFalse);
    });

    test('== returns false for Template and other object types', () {
      final template = Template(id: 'some-id', name: 'Test');
      const otherObject = 'not a template';

      expect(template == otherObject, isFalse);
    });

    test('hashCode is the same for Templates with the same id', () {
      final template1 = Template(id: 'same-id', name: 'Name1');
      final template2 = Template(id: 'same-id', name: 'Name2');

      expect(template1.hashCode, template2.hashCode);
    });

    test('hashCode is different for Templates with different ids', () {
      final template1 = Template(id: 'id-1', name: 'Template A');
      final template2 = Template(id: 'id-2', name: 'Template B');

      expect(template1.hashCode, isNot(template2.hashCode));
    });

    test('hashCode matches id.hashCode', () {
      final template = Template(id: 'specific-id-for-hash', name: 'Hash Test');
      expect(template.hashCode, 'specific-id-for-hash'.hashCode);
    });
  });
}
